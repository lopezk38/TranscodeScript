Powershell scripts designed for my encoding chain. Performs chonologically ordering, transcoding, and renaming video clips generated by NVidia Shadowplay from a set of predefined folders for ingest. 
Additionally transcodes from DNxHR to HEVC for the final product.


Dependencies:

	Powershell (Was written for and tested on Powershell 5.1 - Will probably work on other versions)
	
	ffmpeg

Notes (General):

Whenever ffmpeg is called, it will be called such that there will be multiple instances at once. The amount of spawned instances can be changed
at the top of each script. Currently, instance counts are optimized for an AMD Ryzen 9 3950X and greatly improve performace.



Notes (transcodecpu.ps1):

Each input folder has a predefined time zone attached to them. Clips are assigned a source timezone based upon which folder they are in  
  
The script expects the exact date stamps Shadowplay writes in each clips filename when they are created. Everything else in the filename can be changed.  
  
It currently expects .mp4 input files. It currently outputs DNxHR 1440p 59.94 FPS .mov files.  
  
Giving an input file the name 0 will force it retain the name 0. There can only be one, and it only works for 0, not for any number.



Notes (finaltranscode.ps1):

Expects as many inputs as ffmpeg instances. Currently, ffmpeginstances is set to two, so it expects 2 input files. Export from your video editing program
such that you create multiple (2 by default) files of the same length to feed into the program. I like to feed it DNxHR SQ files - my input files are not
fantastic quality to begin with, so there isn't a noticeable loss in quality by using that. 

ffmpeg does not like PCM audio. Don't feed it that or it will fail to encode

It currently expects .mov input files, and outputs HEVC .mp4 files. Current ffmpeg settings are crf 25 medium. The compression is rather strong, but is just
fine for my purposes.
  
	
	
Basic description of how the ingest script (transcodecpu.ps1) works:  
The script loops through a set of predefined folders. Each of those folders has a pre programmed timezone. It looks in each of these folders, uses regex
to parse the timestamp in the file name, from year all the way down to second, and stores it. It will then modifiy the stored time based upon what
timezone folder the clip came from - it converts everything to Pacific time. It then attempts to rename the clip to a new date stamp format, losing all
other data that may have been stored in the file name. The format is YYYY.MM.DD.HH.MM.SS.DUPECOUNT. The dupecount is used to prevent overwriting other
clips that may have been recorded in the exact same second - It starts at 00 and increases by 1 every time it fails to rename the file, up to 25. If
it hits 25, it skips that clip and beeps angrily. It then copys the renamed clip to a new predefined directory. Once it finishes renaming and copying
clips, it will give you a summary of how many clips it succeded in renaming out of the total amount and pause for 5 seconds. If there were errors, it
will print out the names of the failed clips and wait an additional 10 seconds so you have time to read them. It will then send all the newly copied
and renamed clips through multiple ffmpeg instances simultaneously (currently 4 at a time) by order of oldest to newest based off of the file name. It
enumerates all the clips so that the oldest file is 1, increasing by 1 for each subsequent file. If there was a file named 0, it will be given the
enumeration 0 - This will not cause a gap in enumeration. The outputted files are stored in another predefined folder (All predefined folders are meant
to be on different drives for maximum throughput, but they don't need to be) and then renamed to their enumerated value. The script will then beep happily,
and exit